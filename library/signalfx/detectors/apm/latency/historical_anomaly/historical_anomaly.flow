from signalfx.detectors.apm.latency import conditions


def growth_rate(pctile=90, filter_=None, current_window=duration('5m'),
                historical_window=duration('1h'), cycle_length=duration('1w'), num_cycles=4,
                fire_growth_rate_threshold=0.2, clear_growth_rate_threshold=0.1,
                exclude_errors=True, group_by=None, volume_static_threshold=None,
                volume_pct_fire_threshold=None,
                volume_pct_clear_threshold=None, vol_pctile_req_pos=90):
    # Detect when latency grows by a specified amount relative to its historical baseline
    # :param pctile (number): percentile to monitor, one of 50, 90, 99, default=90
    # :param filter_ (filter): specifies dimensional scope of the detector, default=None
    # :param current_window (duration): window whose latency is evaluated for being too high,
    #                                      default=duration('5m')
    # :param historical_window (duration): historical window length, whose latency is used to define
    #                                       the baseline, default=duration('1h')
    # :param cycle_length (duration): space between historical windows, default=duration('1w')
    # :param num_cycles (positive integer): number of historical windows used to define the baseline,
    #                                       default=4
    # :param fire_growth_rate_threshold (number): latency growth required to trigger, default=0.2
    # :param clear_growth_rate_threshold (number): latency growth required to clear, default=0.1
    # :param exclude_errors (boolean): whether to exclude error spans from latency metric, default=True
    # :param group_by (list of strings): average latency by these (in addition to default grouping
    #                    by cluster, service, operation), default=None
    # :param volume_static_threshold (number): threshold on request rate (per second) required for
    #                    alert to trigger, default=None FIXME?
    # :param volume_pct_fire_threshold (number): require request rate on window being evaluated to be
    #                    at least this proportion of request rate on preceding window (used for
    #                    trigger), default=None FIXME?
    # :param volume_pct_clear_threshold (number): require request rate on window being evaluated to be
    #                    at least this proportion of request rate on preceding window (used for
    #                    clear), default=None FIXME?
    # :param vol_pctile_req_pos (number, percentage): percentage of historical window permitted to
    #                    have request rate 0, default=90, FIXME?
    # :return: detect block that triggers when the specified percentile of latency, suitably
    #           filtered and grouped, over the last current_window is greater than
    #           1 + fire_growth_rate_threshold times the baseline latency (for the same percentile,
    #           similarly filtered and grouped), calculated on num_cycles windows each of length
    #           historical_window and spaced cycle_length apart AND when .... FIXME ;
    #           clears when latency is less than 1 + clear_growth_rate_threshold times the baseline
    current_window_ = duration(current_window)
    historical_window_ = duration(historical_window)
    cycle_length_ = duration(cycle_length)
    assert fire_growth_rate_threshold >= clear_growth_rate_threshold, {
        'fire_growth_rate_threshold': fire_growth_rate_threshold,
        'clear_growth_rate_threshold': clear_growth_rate_threshold,
        'sfui_errorKeys': ['fire_growth_rate_threshold', 'clear_growth_rate_threshold'],
        'sfui_errorTemplate': "{{{fire_growth_rate_threshold}}} must be greater than or equal to {{{clear_growth_rate_threshold}}}."}
    assert pctile == 50 or pctile == 90 or pctile == 99, {
        'pctile': pctile,
        'sfui_errorKeys': ['pctile'],
        'sfui_errorTemplate': "{{{pctile}}} must be one of 50, 90, 99."}
    assert num_cycles >= 1, {
        'num_cycles': num_cycles,
        'sfui_errorKeys': ['num_cycles'],
        'sfui_errorTemplate': "{{{num_cycles}}} must be a positive integer."}
    assert cycle_length_ >= historical_window_, {
        'cycle_length': cycle_length_,
        'historical_window': historical_window_,
        'sfui_errorKeys': ['cycle_length', 'historical_window'],
        'sfui_errorTemplate': "{{{cycle_length}}} must be greater than or equal to {{{historical_window}}}."}
    conds = conditions.growth_rate_ha(filter_, pctile=pctile, current_window=current_window_,
                                      historical_window=historical_window_,
                                      cycle_length=cycle_length_, num_cycles=num_cycles,
                                      fire_growth_rate_threshold=fire_growth_rate_threshold,
                                      clear_growth_rate_threshold=clear_growth_rate_threshold,
                                      exclude_errors=exclude_errors, group_by=group_by)
    non_empty_cond = conditions.volume_ha_nonempty(filter_=filter_, current_window=current_window_,
                                                   historical_window=historical_window_,
                                                   cycle_length=cycle_length_,
                                                   num_cycles=num_cycles,
                                                   exclude_errors=exclude_errors,
                                                   pctile=vol_pctile_req_pos, group_by=group_by)
    if volume_static_threshold is not None and volume_pct_fire_threshold is not None and volume_pct_clear_threshold is not None:
        static = conditions.static_on_volume(current_window_,
                                             volume_static_threshold,
                                             filter_=filter_,
                                             exclude_errors=exclude_errors, group_by=group_by)
        pct = conditions.volume_ha(filter_=filter_, current_window=current_window_,
                                   historical_window=historical_window_,
                                   cycle_length=cycle_length_, num_cycles=num_cycles,
                                   fire_threshold=volume_pct_fire_threshold,
                                   clear_threshold=volume_pct_clear_threshold,
                                   exclude_errors=exclude_errors, group_by=group_by)
        on = conds['on'] and static and pct['on'] and non_empty_cond
        off_ = conds['off'] and pct['off'] and non_empty_cond
    elif volume_static_threshold is not None:
        static = conditions.static_on_volume(current_window_,
                                             volume_static_threshold,
                                             filter_=filter_,
                                             exclude_errors=exclude_errors,
                                             group_by=group_by)
        on = conds['on'] and static and non_empty_cond
        off_ = conds['off'] and non_empty_cond
    elif volume_pct_fire_threshold is not None and volume_pct_clear_threshold is not None:
        pct = conditions.volume_ha(filter_=filter_, current_window=current_window_,
                                   historical_window=historical_window_,
                                   cycle_length=cycle_length_, num_cycles=num_cycles,
                                   fire_threshold=volume_pct_fire_threshold,
                                   clear_threshold=volume_pct_clear_threshold,
                                   exclude_errors=exclude_errors, group_by=group_by)
        on = conds['on'] and pct['on'] and non_empty_cond
        off_ = conds['off'] and pct['off'] and non_empty_cond
    else:
        on = conds['on'] and non_empty_cond
        off_ = conds['off'] and non_empty_cond
    return detect(on, off=off_, annotations=conds['annotations'],
                  event_annotations=conds['event_annotations'])


def deviations_from_norm(filter_=None, current_window=duration('5m'),
                         historical_window=duration('1h'),
                         cycle_length=duration('1w'), num_cycles=4, exclude_errors=True,
                         group_by=None,
                         fire_num_dev_threshold=3.5, clear_num_dev_threshold=3,
                         volume_static_threshold=None, volume_pct_fire_threshold=None,
                         volume_pct_clear_threshold=None, vol_pctile_req_pos=90):
    # Detect when latency is too many deviations from its historical norm
    # :param filter_ (filter): specifies dimensional scope of the detector, default=None
    # :param current_window (duration): window whose latency is evaluated for being too high,
    #                                      default=duration('5m')
    # :param historical_window (duration): historical window length, whose latency is used to define
    #                                       the baseline, default=duration('1h')
    # :param cycle_length (duration): space between historical windows, default=duration('1w')
    # :param num_cycles (positive integer): number of historical windows used to define the baseline,
    #                                       default=4
    # :param exclude_errors (boolean): whether to exclude error spans from latency metric, default=True
    # :param group_by (list of strings): average latency by these (in addition to default grouping
    #                    by cluster, service, operation), default=None
    # :param fire_num_dev_threshold (number): number of historical (P90 - P50)'s from the historical P50
    #                                the current P50 must be in order to trigger, default=3.5
    # :param clear_num_dev_threshold (number): number of historical (P90 - P50)'s from the historical P50
    #                                the current P50 must be in order to clear, default=3
    # :param volume_static_threshold (number): threshold on request rate (per second) required for
    #                    alert to trigger, default=None FIXME?
    # :param volume_pct_fire_threshold (number): require request rate on window being evaluated to be
    #                    at least this proportion of request rate on preceding window (used for
    #                    trigger), default=None FIXME?
    # :param volume_pct_clear_threshold (number): require request rate on window being evaluated to be
    #                    at least this proportion of request rate on preceding window (used for
    #                    clear), default=None FIXME?
    # :param vol_pctile_req_pos (number, percentage): percentage of historical window permitted to
    #                    have request rate 0, default=90, FIXME?
    # :return: detect block that triggers when the latency, suitably filtered and grouped,
    #           over the last current_window is more than
    #           fire_num_dev_threshold deviations from the norm (similarly filtered and grouped),
    #           calculated on num_cycles windows each of length
    #           historical_window and spaced cycle_length apart AND when .... FIXME ;
    #           clears when latency is less than clear_num_dev_threshold deviations from the norm
    current_window_ = duration(current_window)
    historical_window_ = duration(historical_window)
    cycle_length_ = duration(cycle_length)
    assert fire_num_dev_threshold >= clear_num_dev_threshold, {
        'fire_num_dev_threshold': fire_num_dev_threshold,
        'clear_num_dev_threshold': clear_num_dev_threshold,
        'sfui_errorKeys': ['fire_num_dev_threshold', 'clear_num_dev_threshold'],
        'sfui_errorTemplate': "{{{fire_num_dev_threshold}}} must be greater than or equal to {{{clear_num_dev_threshold}}}."}
    assert num_cycles >= 1, {
        'num_cycles': num_cycles,
        'sfui_errorKeys': ['num_cycles'],
        'sfui_errorTemplate': "{{{num_cycles}}} must be a positive integer."}
    assert cycle_length_ >= historical_window_, {
        'cycle_length': cycle_length_,
        'historical_window': historical_window_,
        'sfui_errorKeys': ['cycle_length', 'historical_window'],
        'sfui_errorTemplate': "{{{cycle_length}}} must be greater than or equal to {{{historical_window}}}."}
    conds = conditions.deviations_from_norm_ha(filter_=filter_, current_window=current_window_,
                                               historical_window=historical_window_,
                                               cycle_length=cycle_length_, num_cycles=num_cycles,
                                               exclude_errors=exclude_errors, group_by=group_by,
                                               fire_num_dev_threshold=fire_num_dev_threshold,
                                               clear_num_dev_threshold=clear_num_dev_threshold)
    non_empty_cond = conditions.volume_ha_nonempty(filter_=filter_, current_window=current_window_,
                                                   historical_window=historical_window_,
                                                   cycle_length=cycle_length_,
                                                   num_cycles=num_cycles,
                                                   exclude_errors=exclude_errors,
                                                   pctile=vol_pctile_req_pos,
                                                   group_by=group_by)
    if volume_static_threshold is not None and volume_pct_fire_threshold is not None and volume_pct_clear_threshold is not None:
        static = conditions.static_on_volume(current_window_,
                                             volume_static_threshold,
                                             filter_=filter_,
                                             exclude_errors=exclude_errors,
                                             group_by=group_by)
        pct = conditions.volume_ha(filter_=filter_, current_window=current_window_,
                                   historical_window=historical_window_,
                                   cycle_length=cycle_length_, num_cycles=num_cycles,
                                   fire_threshold=volume_pct_fire_threshold,
                                   clear_threshold=volume_pct_clear_threshold,
                                   exclude_errors=exclude_errors, group_by=group_by)
        on = conds['on'] and static and pct['on'] and non_empty_cond
        off_ = conds['off'] and pct['off'] and non_empty_cond
    elif volume_static_threshold is not None:
        static = conditions.static_on_volume(current_window_,
                                             volume_static_threshold,
                                             filter_=filter_,
                                             exclude_errors=exclude_errors)
        on = conds['on'] and static and non_empty_cond
        off_ = conds['off'] and non_empty_cond
    elif volume_pct_fire_threshold is not None and volume_pct_clear_threshold is not None:
        pct = conditions.volume_ha(filter_=filter_, current_window=current_window_,
                                   historical_window=historical_window_,
                                   cycle_length=cycle_length_, num_cycles=num_cycles,
                                   fire_threshold=volume_pct_fire_threshold,
                                   clear_threshold=volume_pct_clear_threshold,
                                   exclude_errors=exclude_errors, group_by=group_by)
        on = conds['on'] and pct['on'] and non_empty_cond
        off_ = conds['off'] and pct['off'] and non_empty_cond
    else:
        on = conds['on'] and non_empty_cond
        off_ = conds['off'] and non_empty_cond
    return detect(on, off=off_, annotations=conds['annotations'],
                  event_annotations=conds['event_annotations'])
