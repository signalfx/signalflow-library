from signalfx.detectors.autodetect.infra.k8s import utils as k8s_utils

def job_failures_per_cluster_or_namespace_detector(high_failure_job_threshold: float = 0.9,
                                                   fire_threshold_: float = 0.33,
                                                   filter_: filter = None):
    # Detects when the ratio of high-failure jobs per cluster or namespace exceeds 'fire_threshold'
    # :param high_failure_job_threshold label=Threshold for ratio of failed pods per job for a job to be 'high-failure'
    # :param high_failure_job_threshold description=Don't alert for jobs with fewer than this ratio of failed pods. A job is considered 'high-failure' if its ratio of failed pods is higher than this threshold.
    # :param fire_threshold_ label=Fire threshold for ratio of high failure jobs per cluster or namespace
    # :param fire_threshold_ description=Don't alert for cluster or namespace with fewer than this ratio of high-failure jobs.
    # :param filter_ description=Specifies dimensional scope of the detector
    # :param filter_ metric_name=k8s.job.failed_pods
    # :return: detect block that triggers when the ratio of high-failure jobs per cluster or namespace exceeds 'fire_threshold'. A job is high-failure if it ratio of failing pods exceeds 'high_failure_job_threshold'.
    group_by = [k8s_utils.K8S_CLUSTER_NAME_DIM,
                k8s_utils.K8S_NAMESPACE_NAME_DIM,
                k8s_utils.K8S_JOB_NAME_DIM]
    failed_pods_stream = data('k8s.job.failed_pods', filter=filter_, rollup='latest').sum(by=group_by, allow_missing=group_by)
    successful_pods_stream = data('k8s.job.successful_pods', filter=filter_, rollup='latest').sum(by=group_by, allow_missing=group_by)
    stream = (failed_pods_stream / (failed_pods_stream + successful_pods_stream))

    n_job_per_cluster = stream.count(by=k8s_utils.K8S_CLUSTER_NAME_DIM)
    n_high_failure_job_ratio_per_cluster = stream.above(high_failure_job_threshold).count(by=k8s_utils.K8S_CLUSTER_NAME_DIM).fill(0)
    ratio_per_cluster = (n_high_failure_job_ratio_per_cluster / n_job_per_cluster).dimensions(aliases={{"unique_dim": k8s_utils.K8S_CLUSTER_NAME_DIM}}).publish('High-failure jobs ratio per cluster', enable=True)

    n_job_per_namespace = stream.count(by=k8s_utils.K8S_NAMESPACE_NAME_DIM)
    n_high_failure_job_ratio_per_namespace = stream.above(high_failure_job_threshold).count(by=k8s_utils.K8S_NAMESPACE_NAME_DIM).fill(0)
    ratio_per_namespace = (n_high_failure_job_ratio_per_namespace / n_job_per_namespace).dimensions(aliases={{"unique_dim": k8s_utils.K8S_NAMESPACE_NAME_DIM}}).publish('High-failure jobs ratio per namespace', enable=True)

    # NOTE cannot have MTS with different dimensions in detect block
    high_failure_job_ratios_combined = union(ratio_per_cluster, ratio_per_namespace)
    fire_threshold = threshold(fire_threshold_)
    return detect(
        when(high_failure_job_ratios_combined > fire_threshold, lasting=lasting('15m', 0.8)),
        off=when(high_failure_job_ratios_combined < 0.5 * fire_threshold, lasting('40m', 0.9)),
        auto_resolve_after=duration('1d')
    )
