from signalfx.detectors.autodetect import utils
from signalfx.detectors.apm.latency.sudden_change_v2 import sudden_change as latency_sudden_change_v2


def latency_deviations_from_norm_detector(current_window: duration = duration('10m'),
                                          historical_window: duration = duration('1h'),
                                          fire_num_dev_threshold: float = 5.0,
                                          clear_num_dev_threshold: float = 4.0,
                                          volume_relative_threshold_perc: float = 20,
                                          filter_: filter = None):
    # :param current_window label=Current window
    # :param current_window description=Time window to test for anomalous values
    # :param historical_window label=Historical window
    # :param historical_window description=Time window to use for historical normal values
    # :param fire_num_dev_threshold label=Trigger threshold
    # :param fire_num_dev_threshold description=Trigger the alert when the current value is greater than this number of deviations above historical norm
    # :param clear_num_dev_threshold label=Clear growth threshold
    # :param clear_num_dev_threshold description=Clear the alert when the current value is less than this number of deviations above historical norm
    # :param volume_relative_threshold_perc label=Min. req/sec (% of history)
    # :param volume_relative_threshold_perc description=Minimum request rate, as a percentage of historical request rate, required in current window to trigger or clear the alert; prevents alerts for sparse data.
    # :param volume_relative_threshold_perc min=0
    # :param volume_relative_threshold_perc max=100
    # :param volume_relative_threshold_perc unit=%
    # :param filter_ metric_name=service.request.duration.ns.p90
    # :param filter_ dimensions=deployment.environment,service.name
    # :viz valueUnit=Millisecond
    # :return: detect block that triggers when latency is too many deviations from the norm established in the preceding window
    volume_relative_threshold_rate = volume_relative_threshold_perc * 0.01

    return latency_sudden_change_v2.deviations_from_norm(filter_=filter_, current_window=current_window,
                                                         historical_window=historical_window,
                                                         fire_num_dev_threshold=fire_num_dev_threshold,
                                                         clear_num_dev_threshold=clear_num_dev_threshold,
                                                         volume_relative_threshold=volume_relative_threshold_rate,
                                                         resource_type='service',
                                                         auto_resolve_after=utils.AUTO_RESOLVE_AFTER)


def blended(guard: float = 500, headroom: float = 2.0, filter_: filter = None):
    # Detect when latency degrades, compared to historical latencies
    # :param guard label=Heuristic floor (millis)
    # :param guard description=Don't alert for latencies under this.
    # :param headroom label=Headroom multiplier (unitless; usually between 1.2 and 3.0)
    # :param headroom description=How much worse latency must be, compared to historical, in order to trigger an alert.
    # :param filter_ label=Additional filter
    # :param filter_ description=Optionally refine the set of observed entities with an additional filter.
    # :param filter_ metric_name=service.request
    # :return: detect block that triggers when latency degrades
    guard_nanos = guard * 1e6
    if filter_ is None:
        _filter = filter('sf_error', 'false')
    else:
        _filter = filter_ and filter('sf_error', 'false')
    by_ = ['sf_service', 'sf_environment']
    p90 = histogram('service.request', filter=_filter, resolution='1s').percentile(pct=90, by=by_).publish('P90 Latency')
    p90_today = p90.percentile(pct=80, over='12h').publish('Today')
    p90_yesterday = p90.percentile(pct=80, over='2h').timeshift('23h').publish('Yesterday')
    p90_weekago = p90_yesterday.timeshift('6d').publish('Week Ago')
    alert_level = max(max(p90_today, p90_yesterday, p90_weekago) * headroom, guard_nanos)
    return detect(
        on= when(p90 > threshold(alert_level), lasting='15m', at_least=0.8),
        off=when(p90 <= threshold(alert_level), lasting='20m', at_least=0.85),
        auto_resolve_after='1d',
    )
